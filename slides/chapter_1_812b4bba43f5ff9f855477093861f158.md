---
title: Insert title here
key: 812b4bba43f5ff9f855477093861f158

---
## Getting started with Thresholding and Histogram Equalization

```yaml
type: "TitleSlide"
key: "45a44c3164"
```

`@lower_third`

name: Rebeca Gonzalez
title: Data Engineer


`@script`
Now we are going to get our hands on Scikit-image and start with Thresholding and Histogram Equalization.


---
## Thresholding

```yaml
type: "TwoColumns"
key: "2bb9b49fda"
center_content: true
```

`@part1`
Partitioning an image into a foreground and background, converting grayscale images into binary images.

e.g. The function T(pixel) will return: {{2}}

- 255 (white) if pixel **>** thresh value {{2}}
- 0 (black) if pixel **<** thresh value {{2}}


Works better in gray-scale images because these only use one channel. {{3}}


`@part2`
![](https://assets.datacamp.com/production/repositories/4365/datasets/de9a4ae8aed79a5570320ec2e348b1f3673022e2/camera_thresholding_row.png){{1}}


`@script`
Thresholding help us to separate objects from a background by creating a binary image from a gray-scale one.

Essentially, its converting the image completely black and white. Also the simplest method, yet effective, of image segmentation, something that we will cover in more detail later on, in the course. 

In this way, is a function that takes 2 arguments: the image pixel and the thresh value to compare with.

The Thresholding function will return a white pixel, which is 255, if the pixel that's evaluating is greater than the thresh value to compare with. And will return a black pixel otherwise.

Here we can see how it takes effect on an image. 

Works its best in gray-scale images and this is mainly because these images only use one channel.


---
## Inverted thresholding

```yaml
type: "TwoColumns"
key: "a9ac55415c"
```

`@part1`
The opposite of the positive thresholding.
 
The function T(pixel) will return: {{1}}

- 255 (white) if pixel **<** thresh value {{1}}
- 0 (black) if pixel **>** thresh value {{1}}


`@part2`
![](https://assets.datacamp.com/production/repositories/4365/datasets/e418d89a0a22e0660ac6d7abeca46d18fa81977f/camera_inverted_thresholding.png){{1}}


`@script`
There is also inverted thresholding, this one acts just in the opposite way of the positive thresholding, the one that we just saw.

Here we can see how the background of this image, instead of being white (which is 255), is black (0).


---
## Apply it

```yaml
type: "TwoColumns"
key: "714e04f902"
center_content: true
```

`@part1`
```python
import skimage.data as data

image = data.camera()

thresh = 127

```{{1}}
```python
thresholded_image = image > thresh
inv_thresholded_image = image <= thresh

show_images(image, 
            thresholded_image, 
            inv_thresholded_image)
```{{2}}
![](https://assets.datacamp.com/production/repositories/4365/datasets/68321ee87a6c9805730b7aa83586f6df8e34ed28/all_thresholding.png){{2}}


`@part2`
The module data in scikit image contains multiple images for testing. {{1}}

We apply thresholding using the "**>**" operator. {{2}} 

To apply inverted thresholding we can use "**<=**" operator. {{2}}


`@script`
Let's now apply it.

First we need an image to work on, for this we'll use a module from scikitimage that includes many images for testing reasons. We import the module, then choose a grayscaled image: camera, set the thresh value to 127, which is the whole number midpoint between 0 and 255.

We apply thresholding on an image using the grater than operator followed of the thresh value. 

For inverted thresholding, we use the less or equal than operator. 

Finally show the image using a pre-loaded function that plots using matplotlib, called show_images to help us focus on scikit image.


---
## Types of Thresholding

```yaml
type: "FullSlide"
key: "74c101ba7b"
```

`@part1`
- **Histogram-based:** The histogram of the pixels’ intensity is used and certain assumptions are made on the properties of this histogram.
- **Local:** Processes a pixel, only the neighboring pixels are used.

![](image-url)
### Algorithms 
Some methods included in scikit image are: 

Isodata, li, mean, minimum, otsu, triangle and yen.


`@script`
There are mainly two categories of thresholding in scikit-image:
Histogram-based. Where the histogram is a graphical representation of the frequency distribution table of the image and its density. It acts based on the properties of this histogram.

There is also local thresholding. This is used to process a pixel, where only the neighboring pixels are used. These kind of algorithms often require more computation time.

Methods as Isodata, Li’s iterative Minimum Cross Entropy and otsu are included in scikit-image.


---
## What thresholding algorithm to use

```yaml
type: "TwoRows"
key: "f817589f10"
```

`@part1`
```python
from skimage import data
from skimage.filters import try_all_threshold

image = data.page()

fig, ax = try_all_threshold(image, verbose=False)

show_plot()

```


`@part2`
![](https://assets.datacamp.com/production/repositories/4365/datasets/66a70de36e3e27742742ec170a947fa4e98bdaa5/trying_all_alg_horizontal.png)


`@script`
You might be asking what thresholding algorithm would be better to use. It's okay if you don't know in deep how these methods work, scikitimage includes a function to evaluate them so you can choose the one that best suits you.

This is the try_all_threshold function, from the scikit-image  filters module.

Here we are importing it, setting the image from data, using the function and showing the results.


---
## Bimodal histogram

```yaml
type: "TwoRows"
key: "a9210d59db"
```

`@part1`
```python
from skimage.filters import threshold_minimum

image = data.camera()

min_thresh = threshold_minimum(image)

thresholded_image = image > min_thresh

compare_images_bimodal(image, thresholded_image, min_thresh)
```


`@part2`
![](https://assets.datacamp.com/production/repositories/4365/datasets/c6f1ea3a8131fee935101da84e27248abd029d72/bimoal_histogram_horizontal.png)


`@script`
Previously, we manually set the thresh value, but a better way to know what thresh value could work better on an image is to calculate it using a bimodal histogram method. In this case we are trying the minimum algorithm. 

Which takes a histogram of the image and smooths it repeatedly until there are only two peaks in it.

So the thresh will be the minimum in between those two peaks.

This is done with the threshold_minimum function.

Faster than manually trying numbers.

We can see how the the minimum is spotted by a red line.


---
## Calculating the optimal thresh

```yaml
type: "TwoRows"
key: "3306dc3ade"
center_content: false
```

`@part1`
```python
from skimage.filters import threshold_otsu

image = data.camera()

optimal_thresh = threshold_otsu(image)

thresholded_image = image > optimal_thresh

compare_images_bimodal(image, thresholded_image, optimal_thresh)
```


`@part2`
![](https://assets.datacamp.com/production/repositories/4365/datasets/fe54cd5bbd915b2379abdbcac98bfcb10ff4cf40/optimal_thresh.png)


`@script`
We can calculate a possible optimal threshold with the threshold_otsu function.

This is a clustering-based method that maximizes the variance between two classes of pixels, separated by the threshold.

Simple and effective.


---
## Final Slide

```yaml
type: "FinalSlide"
key: "14704661f7"
```

`@script`


